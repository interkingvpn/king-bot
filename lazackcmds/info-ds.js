import { promises as fs } from 'fs'
import path from 'path'

/**
 * Manejador para eliminar archivos de sesi√≥n de un chat o usuario espec√≠fico.
 */
const handler = async (m, { conn }) => {
  // Solo permitir este comando en el n√∫mero principal del bot
  if (global.conn.user.jid !== conn.user.jid) {
    return conn.reply(m.chat, `‚ö†Ô∏è Por favor, utiliza este comando directamente desde el n√∫mero principal del bot.`, m)
  }

  // Si es grupo, revisar tanto el ID del grupo como el del remitente
  const chatIds = m.isGroup ? [m.chat, m.sender] : [m.sender]
  const sessionPath = `./${sessions}/`

  try {
    const files = await fs.readdir(sessionPath)
    let deletedFilesCount = 0

    for (const file of files) {
      for (const id of chatIds) {
        if (file.includes(id.split('@')[0])) {
          await fs.unlink(path.join(sessionPath, file))
          deletedFilesCount++
          break
        }
      }
    }

    if (deletedFilesCount === 0) {
      await conn.reply(m.chat, `‚ÑπÔ∏è No se encontraron archivos de sesi√≥n para este chat/usuario.`, m)
    } else {
      await conn.reply(m.chat, `‚úÖ Se eliminaron correctamente ${deletedFilesCount} archivo(s) de sesi√≥n.`, m)
      await conn.reply(m.chat, `üëã ¬°Hola! ¬øPuedes verme ahora?`, m)
    }
  } catch (err) {
    console.error('Error al leer o eliminar archivos de sesi√≥n:', err)
    await conn.reply(
      m.chat,
      `‚ö° ¬°Hola! Soy ${botname}. Por favor sigue y ap√≥yanos en nuestro canal:\n\n> ${channel}`,
      m
    )
  }
}

// Configuraci√≥n del comando
handler.help = ['ds', 'fixwaitingmsg']
handler.tags = ['info']
handler.command = ['fixwaitingmsg', 'ds']
handler.register = true

export default handler